Reset_Hander引导进入main函数前要先进入systemInit（长这样system_stm32f4xxx.c 在USER里面）

systemInit的作用是把系统初始化

#### GPIO

STM32大部分引脚除了当GPIO使用外，还可以复用为外设功能引脚（比如：串口）

GPIO输入模式下可读取端口高低电平。

输出模式下可控制输出高低电平以驱动LED

不管是输入还是输出寄存器写1，对应引脚输出高电平，反之低电平

**输入部分**：

##### 保护二极管的作用

IO引脚接了两个保护二极管，对输入电压限幅。上接VDD，下接VSS。

若输入电压比VDD大，则上方二极管导通，输入电压，产生的电流会直接流入VDD，而非内部电路（以免高压伤害内部电路）；

若输入电压比VSS小，则输入电压会直接经过VSS（VSS电压为0，比VSS小为相对的负电压），而不会从内部电路汲取电流（也用于保护电路）；

若输入电压在VDD和VSS中间，两个二极管都不会导通。

**上下拉电阻的作用**

上拉电阻至VDD，下拉电阻至VSS，上拉电阻导通下拉电阻断开为上拉输入，反之为下拉输入。两个都拉开为浮空输入。

目的是给输入提供一个默认的输入电平

若输入啥也不接会处于浮空状态，引脚的输入电平易受到外界干扰而改变。

上拉输入高电平，下拉输入为低电平

**施密特触发器**

对输入电压进行整形，如果输入电压大于某一值，输出瞬间升为高电压

输入电压小于某一值，输出瞬间降为低电压

**输出数据寄存器**

模拟输入，复用功能输入

**输出数据寄存器**（普通IO口输出）

数据寄存器为1时，上导下断，输出直接连到VDD，输出高电压

数据寄存器为0时，上断下导，输出直接连到VSS，输出低电压

此模式下高低电平均有较强驱动的能力，所以推挽输出模式为强推输出模式

#### 工作方式

**工作方式**： 4种输入模式，4种输出模式，4种最大输出速度（只是初步了解，具体的还没深入研究）

##### 输入模式1—输入浮空模式

浮空：没有输入信号时，上拉电阻和下拉电阻都不起作用

电平从IO口输入，经过可以配置的上拉下拉电阻，进入施密特触发器并将其打开，然后电平输入数据寄存器，然后CPU读取数据寄存器了解IO口的状态。

##### 输入模式2—输入上拉模式

上拉：没有输入信号时，读取到的默认为高电平

电平从IO口输入，经过上拉电阻使之VDD连上，然后经过施密特触发器并将其打开，然后电平输入数据寄存器，然后CPU读取数据寄存器了解IO口的状态。

##### 输入模式3—输入下拉模式

下拉：没有输入信号时，读取到的默认为低电平

电平从IO口输入，经过下拉电阻接地，然后经过施密特触发器并将其打开，然后电平输入数据寄存器，然后CPU读取数据寄存器了解IO口的状态。

##### 输入模式4—模拟模式

施密特触发器是关掉的，电压信号是经过模拟通道，到达片上外设（AD）（其实模拟模式这里是没听懂的）

##### 输出模式1—开漏输出模式

通过CPU写相关寄存器，然后通过输出控制电路，输出1时N—MOS管为打开状态（NMOS是高电平导通）输入0时NMOS管为关闭状态，再输出到IO管口。同时IO管口的状态也会被CPU读取

<u>*只可以输出强低电平，高电平要靠外部电阻加高。适合于做电流型的驱动，吸收电流的能力较强*</u>

##### 输出模式2—开漏复用输出模式

和开漏输出差不多，就控制来源不同。开漏是通过CPU写寄存器来控制，而开漏复用是通过复用功能外设来控制输入输出。

##### 输出模式3—推挽输出模式

和开漏输出很相似，但是多了PMOS管，当输出控制电路输出1时，打开NMOS管，输出开关电路输出0时，打开PMOS管

<u>*可以输出强高低电平，连接数字器件*</u>

##### 输出模式4—推挽复用输出模式

和推挽输出模式差不多，唯一不同在于推挽复用输出模式是通过复用功能外设来控制输入输出，而推挽输出模式是通过CPU写相关寄存器。



对于任意一个IO口，有FT标识则支持5V容忍。极少数IO口不支持5V容忍。

#### 寄存器

##### GPIO端口的寄存器

每组GPIO口都有10个寄存器，一共可以控制一组GPIO的16个IO口

分别为4个32位配置寄存器，2个32位数据寄存器，1个置位/复位寄存器，1个配置锁存寄存器，2个复用功能寄存器



##### 端口模式寄存器（GPIOx_MODER）

写入00：IO口输入；写入01：IO口输出（通用）；写入10：IO口进入复用功能模式；写入11：IO口进入模拟模式（其实没怎么看懂这里）

##### 端口输出类型寄存器（GPIOx_OTYPER）

写入0：输出推挽（复位状态）；写入1：输出开漏

##### 端口输出速度寄存器（GPIOx_OSPEEDR）

写入00:2MHz（低速）；写入01:25MHz（中速）；写入10:50MHz（快速）；写入11:30pF时为100MHz（高速）（15pF时为80MHz输出，最大速度）

##### 端口上拉、下拉寄存器（GPIOx_PUPDR）

写入00：无上拉或下拉；写入01：上拉；写入10：下拉；写入11：保留

#### 重要函数

**初始化函数**： void GPIO_Init  (初始化一个或多个IO口的工作模式，输出类型，速度，上下拉方式。也就是一组IO口的4个配置寄存器，前提是这些IO口的配置方式一样)

**读取输入电平函数**： uint8_t GPIO_ReadOutputDataBit   （读取某个GPIO的输入电平，实际操作的是GPIOx_IDP）

​                                    uint16_t GPIO_ReadOutputData（读取某个GPIO的输入电平，实际操作的是GPIOx_IDP）

**读取输出电平函数**： uint8_t GPIO_ReadOutputDataBit（读取某个GPIO的输出电平，实际操作的是GPIO_ODR寄存器）

​                                    uint16_t GPIO_ReadOutputData  （读取某个GPIO的输出电平，实际操作的是GPIO_ODR寄存器）

**设置输出电平函数**：void GPIO_SetBits   （设置某个IO口输出为高电平，实际操作的是BSRRL）

​                                   void GPIO_ResetBits  （设置某个IO口输出为低电平，实际操作的是BSRRH）

​                                   void GPIO_WriteBit     

​                                   void GPIO_Write  

##### 跑马灯代码：

向LED输入1，两边没有压差，灯就会灭；输入0，两边有压差，灯就亮。（另一端通过电阻后和VCC连接，电压高）。要达到输出高低电平的目的，使用推挽输出。

库函数使用stm32f4xx_gpio.h和stm32f4_gpio.c头文件

使用主要为misc.c    stm32f4xx_rcc.c    stm32f4xx_gpio.c （IO口的相关函数）     ustart.c(串口使用)



assert_param对参数有效性进行判断，间接指出输入的值的形式。例如：从GPIO_Init下的param右键go todefinition下得知GPIO从A排到K，从而代码中输入相应的值。

GPIO_Init(GPIOF,&GPIO_InitStructure)初始化GPIOF9，F10；

while(1){   }循环输入高低电平

delay_ms()延时

set为高电平，reset为低电平，可以理解为一般默认为高电平，所以低电平的时候要重置即reset

需要初始化的变量有pin   mode   otype    pupd     speed

#### 遇到的问题

1 stlink老是connection error

没有准备好stlink，没有更新好

2 keil  报错问题，loading PDSC Debug Description failed forSTMicroelectronics STM32 .....

找到对应路径，把只读属性去掉，打开文件，把message（2，“not a genuine st device abort connection”）删除，最后把只读属性勾上

3 keygen打不开

防火墙关了，但是防病毒的没关
